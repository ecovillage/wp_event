#!/usr/bin/env ruby

require 'wp_event'
require 'optparse'
require 'json'

extend WPEvent::CLI::Logging
extend WPEvent::CLI

options = {}

option_parser = OptionParser.new do |opts|
  opts.banner = <<~USAGE
    Usage: #{$PROGRAM_NAME} [options] FILE

    Sync a list of events with events registered in wordpress instance.

    FILE is supposed to be a json array of hashes (uuid:, name:, description:, fromdate:, todate:, image_url:, category_names:, referee_qualifications: [{uuid:, qualification:}], arrival:, departure:, current_infos:, info_housing:, costs_participation:, costs_catering:, registration_needed:, participants_please_bring:, participants_prerequisites:).
    Alternatively, will read from STDIN.
    Will exit with 0 on success

  USAGE

  opts.on("-r", "--[no-]ignore-missing-referees", "Do not exit if a associated referee is not found in the wordpress installation") do |r|
    options[:ignore_missing_referees] = r
  end

  opts.on("-s", "--image-store=PATH", "Path where to search images (to upload)") do |s|
    options[:image_store] = s
  end

  opts.separator "Common options"
  opts.on("-v", "--[no-]verbose", "Run verbosely") do |v|
    options[:verbose] = v
  end
  opts.on_tail("-h", "--help", "Show this message and exit") do
    puts opts
    exit
  end
  opts.on_tail("--version", "Show version and exit") do
    puts WPEvent::VERSION
    exit
  end
end

# Process options
option_parser.parse!

WPEvent.logger.level = options[:verbose] ? Logger::DEBUG : Logger::INFO

debug "Starting event sync (#{WPEvent::VERSION})"

if ARGV.length != 1 && STDIN.tty?
  STDERR.puts "Please provide json input file or pipe into me."
  puts option_parser
  exit 1
end

begin
  WPEvent.load_conf
rescue Errno::ENOENT
  exit_with 3, "Config file (wp_event.conf) not found."
end

if (STDIN.tty? && ARGV.length == 1) && !File.exist?(ARGV[0])
  exit_with 4, "Input file does not exist!"
end

#if !STDIN.tty?
#  ARGV[0] = STDIN
#end

begin
  # File.read or ARGF
  input = ARGV.length == 1 ? File.open(ARGV[0]) : STDIN
  json = input.read
  events = JSON.parse json
rescue JSON::ParserError => e
  debug $!
  exit_with 5, "Input file could not be parsed."
end

event_cache    = WPEvent::EntityCache.new(WPEvent::EventPost)
media_cache    = WPEvent::MediaLibraryCache.new
image_uploader = WPEvent::ImageUploader.new options[:image_store], media_cache

syncer = WPEvent::Syncer.new image_uploader

event_factory = WPEvent::EventFactory.new raise_on_missing_referee: !options[:ignore_missing_referees]

events.each_with_index do |event, idx|
  info "(#{idx + 1}/#{events.length}) dealing with event with uuid #{event['uuid']}"

  begin
    # 'event' is the new data
    wp_event_content = event_cache.in_mem_lookup event["uuid"]
    debug "wp_event_content from cache is #{wp_event_content}"

    event_from_json  = event_factory.from_json event # Now keys are symbols!
    event_from_wp    = WPEvent::CustomPostTypes::Event.from_content_hash(wp_event_content)

    attachment_id = image_uploader.process(event[:image_url])
    event_from_json.featured_image_id = attachment_id

    syncer.merge_push event_from_json, event_from_wp

  rescue WPEvent::MissingCategoryError => e
    exit_with 7, "A required category does not exist, aborting."
  rescue WPEvent::MissingRefereeError => e
    exit_with 8, "A required referee (in uuids: #{e.missing_referees})"\
                 " does not exist, aborting."
  end
end

exit 0
